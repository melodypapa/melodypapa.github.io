<section id="title">内存系统（**Memory System**）</section>

本章介绍内存系统。

# 1. 关于内存系统

内存系统控制对内部（**internal RAM**）、缓存（**caches**）、外部内存（**external memory**）和外设端口（**peripheral port**）的访问。

内存系统包括：

* 每个内核专用的内存：
  * 可选的 L1 指令缓存。
  * 可选的 L1 数据缓存。
  * 可选的 TCM。
* 每个内核专用的接口：
  * 符合 AXI4（32 位数据总线）的可选LLPP主接口（**LLPP master interface**）。
  * 符合 AXI4 的可选 Flash 接口，但仅支持事务子集并具有一些附加功能（这些功能不必使用）。
  * 符合 AXI4（128 位数据总线）的 AXIM 接口（**AXIM interface**）。
* 符合 AXI4 但仅支持事务子集的 AXIS 接口，提供对所有内核中的 TCM 的外部访问（128 位数据总线）。

下图显示了内存系统和外部接口。

![Figure8_1](Figure8_1.png)

内核采用哈佛内存架构，这意味着内核具有访问指令和数据的独立路径。指令端获取指令。数据端读取和写入数据。内核可以从指令端和数据端进行并发访问。

**TCM** 提供快速访问内存。 **TCM** 是统一的，这意味着它可以同时保存指令和数据。 **TCM接口** 控制对 **TCM** 的访问。 **TCM接口**包括一个完整的交叉开关，允许从三个主控（指令端、数据端和 AXIS）并发访问 **TCM**（A、B 和 C）。如果一个或多个主控尝试访问同一个 **TCM**，则 **TCM** 接口将根据具有服务质量 (QoS) 机制的固定优先级方案在请求之间进行仲裁。 **TCM** 为内存访问提供最确定的时序(**most deterministic timing**)。

当访问时序确定性不太重要但仍需要快速访问时，可以使用指令缓存和数据缓存。数据端生成的所有针对 **AXIM接口** 的存储，都通过 **AXIM接口** 写入外部存储器，并在数据缓存(**data cache**)中更新或分配。**TCM 和 LLPP 事务** 永远不会分配到数据缓存(**data cache**)中。在缓存未命中时，将向 Flash 或 **AXIM接口**发出行填充请求。数据缓存始终具有直写(**Write-Through**)行为。

**AXIM接口**是外部存储器或设备系统的主要接口。**Flash接口**提供对外部只读存储器控制器（如：闪存）的访问。**LLPP接口**提供对外部外围设备或小型专用存储器系统的访问。**AXIS接口** 提供对 TCM 的外部访问。通过 **AXIS接口** 的访问争夺 TCM 访问周期，因此它们可能会降低 TCM 存储器的确定性。

存储器系统包括一个用于独占访问的本地监视器。可以使用独占加载和存储指令（例如：**LDREX**、**STREX**）来提供进程间同步和信号量。它们可以使用适当的外部存储器监控逻辑提供进程间同步和信号量。有关 Armv8-R AArch32 体系结构配置文件，请参阅补充Armv8的Arm® 体系结构参考手册(**Arm® Architecture Reference Manual Supplement Armv8**)。

所有指令端和数据端访问都在**MPU**定义的内存映射中查找。它在指令端或数据端访问外部存储器之前返回访问权限。如果允许访问，**MPU**将为事务提供内存属性。

**注意：**

除了 TCM 与 Flash 重叠的情况（如果存在并启用），执行访问 ATCM、BTCM 和 CTCM 区域中超过一个区域的访问是非法的。此外，如果存在，执行访问 LLPP、Flash 和内部外设区域中超过一个区域的访问也是非法的。

# 2. **TCM 内存**

**TCM** 是统一的，提供快速访问，并具有最确定的内存访问时序(**most deterministic memory access timing**)。

**TCM** 是内核私有的。每个 **TCM** 的大小都独立实现为 **0KB**、**8KB**、**16KB**、**32KB**、64KB、128KB、256KB、512KB 或 1MB。0KB 大小表示未实现 TCM。

每个 **TCM** 都可以实现等待状态，这意味着对该 **TCM** 的所有访问，都会产生额外的延迟周期。如果部分（但不是全部）**TCM** 实现了等待周期，则 **TCM** 的性能可能会各不相同。

如果在复位时，对主输入 **CFGTCMBOOTx** 进行置位，则启用 **ATCM**，基址为 **0x00000000**。其他 **TCM** 则被禁用，其基址为 **未知**。

每个 **TCM** 的基地址以及是否启用，可以通过写入相应的 **TCM** 区域寄存器 (**IMP_ATCMREGIONR**、**IMP_BTCMREGIONR**、**IMP_CTCMREGIONR**) 进行编程。为在 **EL2** 上运行的软件和在 **EL1** 或 **EL0** 上运行的软件，提供独立的启用（**Separate enables**）。**TCM** 基地址必须是大小对齐的。每个 **TCM** 的大小在相应的 **TCM** 区域寄存器中指示。如果当前异常级别禁用了**TCM**，则根据 **Flash接口**的配置，可以通过**AXIM接口**、**Flash接口**或**LLPP接口**访问其地址区域。

通过设置寄存器位 **HCR.TIDCP=1**，可以从 **EL1** 向TCM区域寄存器写入，并将其捕获到在EL2上运行的虚拟机管理程序中。

可以通过**AXIS接口**访问 **TCM**。

**TCM 属性和权限**

启用的 **TCM** 始终表现为：不可缓存、不可共享的普通内存。这与 **MPU** 中，为包含 **TCM** 中保存的地址的内存区域定义的内存类型属性无关。**TCM**访问的访问权限与**MPU**分配给同一地址的权限属性相同。

# 3. 一级缓存(Level-1 caches)

在内核中，可选的指令和数据缓存独立实现。

**指令缓存**

指令缓存的功能包括：

* 指令缓存（如果存在）可实现为 **4KB**、**8KB**、**16KB** 或 **32KB**，并以 **64字节**行四路组相联的方式组织。
* 根据缓存能力属性、缓存隔离策略以及控制缓存的设置的编程方式，来自 Flash 或 AXIM 接口的指令可缓存在指令缓存中。
* 当指令流是连续的时，缓存可以自动从内存中预取下一行。**PFU**使用其分支预测结构提前请求非连续行。
* 预取行为由 **CPUACTLR.L1IPFCTL** 控制。

**数据缓存**

数据缓存的功能包括：

* 数据缓存（如果存在）可实现为 **4KB**、**8KB**、**16KB** 或 **32KB**，并以四路组（**four-way set**）相联的方式组织，每路**64字节**。
* 根据 **MPU** 中设置的属性、缓存隔离策略以及控制缓存的设置编程方式，可将来自 Flash 或 AXIM 接口的数据读取缓存在数据缓存中。
* 当管道中的两个或三个访问在数据缓存中未命中时，内存系统可以为它们全部启动行填充。这种所谓的未命中下未命中行为（**miss-under-miss behavior**）允许缓存同时有最多三个未完成的行填充。
* **AXIM接口**有4个数据预取器，它们在 4KB 区域内的可缓存访问和预取中查找模式。**Flash接口**没有数据预取器。

**Cortex®-R52+** 处理器不具有一致性，内部可共享域由单个 **Cortex®-R52+** 内核组成。**Cortex®-R52+** 处理器不会缓存标记为可共享的数据，并且所有缓存维护指令都在本地执行。这意味着指令缓存维护操作不会广播到任何其他内核。外部可共享域位于 **Cortex®-R52+** 处理器外部，所以依赖于系统。

在 **Cortex®-R52+** 处理器中，指令端和数据端访问具有访问主内存的独立路径。所以一致性点存在于处理器外部，依赖于系统。

内部可缓存域由单个 **Cortex®-R52+** 内核组成。外部可缓存域位于 **Cortex®-R52+** 处理器外部。

数据缓存的写入行为始终为直写缓存（**Write-Through caching**）。标记为可回写缓存（**Write-Back Cacheable**）的位置被视为直写（**Write-Through**）。回写（**Write-Back**）和直写（**Write-Through**）区域的缓存取决于所设置的任何读取分配（**Read-Allocate**）或写入分配（**Write-Allocate**）提示。标记为内部或外部可共享（**Inner or Outer Shareable**）的位置，无论其可缓存性属性如何，都将被视为不可缓存。数据缓存不使用瞬态分配提示（**Transient allocation hint**）。任何标记为瞬态的区域都将被视为非瞬态（**Non-transient**）。

## 3.1. 缓存RAM组织

本节介绍指令和数据缓存的 RAM 组织。

**在 Cortex®-R52+** 处理器中，指令和数据缓存均组织为4路组（**4-way set**）相联结构，引脚可配置逻辑大小为 **4KB**、**8KB**、**16KB** 或 **32KB**。

**Cortex®-R52+** 地址宽度为**32**位。每个缓存行（**cache line**）包含64个字节的数据，每条逻辑通道（**logical way**）都是一个双字宽（8字节）。位 [5:3] 用于选择缓存行内的双字地址。位 [2:0] 允许选择双字内的字节。

根据缓存的大小，缓存的标签和索引来自 32 位地址，如下表所示。

![Table8_1](Table8_1.png)

该信息有助于通过缓存调试操作来调试缓存，如8.4直接访问L1缓存中所述。

### 指令缓存（Instruction cache）

本节介绍指令缓存标记和数据RAM的组织。

**标记RAM（Tag RAM）**

指令缓存标记RAM分为四条逻辑通道（**logical way**），每条路包含 **64** 到 **512** 个条目（**entries**），具体取决于缓存的大小。每个条目包含一个有效位（**valid bit**）、一个标记（**tag**），以及可选的六个纠错码 (**ECC**) 位。

四条逻辑通道中的每一条都可以实现为一个物理存储体（**physical bank**），如下图所示。

![Figure8_2](Figure8_2.png)

下表显示了根据指令缓存的大小每个标记 RAM 条目的位字段。

![Table8_2](Table8_2.png)

指令缓存标记 RAM 的有效位与指令缓存数据 RAM 中的整个缓存行（八个双字条目）相关联。

**数据RAM（Data RAM）**

指令缓存数据RAM分为四条逻辑通道，每条路径包含 **64** 到 **1024** 个条目。每个条目包含 64位（双字）数据和可选的七个纠错码 (**ECC**) 位。

四条逻辑通道中的每一条都映射到所有四个物理存储体，如下图所示。

![Figure8_3](Figure8_3.png)

给定双字的物理存储体（**physical bank**）取决于双字在缓存行内的偏移量（由地址位 [5:3] 给出）和逻辑通道，具体公式如下：

双字的指令缓存数据 RAM 存储体 = (缓存路径 XOR 数据双字偏移量) AND 0x3

下表显示了每个指令缓存数据 RAM 条目的位字段，与缓存大小无关。

![Table8_3](Table8_3.png)

数据缓存标记 RAM 分为四个逻辑通道，每个通道包含 64 到 512 个条目，具体取决于缓存的大小。每个条目包含一个有效位、一个标记以及可选的六个纠错码 (ECC) 位。

### 数据缓存（Data cache）

本节介绍数据缓存标记和数据RAM的组织。

**标记RAM（Tag RAM）**

**数据缓存标记RAM**分为四个逻辑通道，每个通道包含 **64** 到 **512** 个条目，具体取决于缓存的大小。每个条目包含一个有效位、一个标记以及可选的六个纠错码 (ECC) 位。

四个逻辑通道中的每一条都可以实现为一个物理存储体，如下图所示。

![Figure8_4](Figure8_4.png)

下表显示了根据数据缓存的大小每个**标签 RAM**条目的位字段。

![Table8_4](Table8_4.png)

数据缓存标记 RAM 的有效位与数据缓存数据 RAM 中的整条缓存行（八个双字条目）相关联。

**数据RAM（Data RAM）**

**数据缓存数据RAM**分为四条逻辑通道，每条通道包含 **64** 到 **1024** 个双字数据条目。但是，从物理上讲，**数据缓存数据RAM**实现为八个存储体，每个条目包含 32位（一个字）数据和可选的六个ECC位。

四个逻辑通道映射到所有八个物理存储体上，如下图所示。一个双字始终存储在两个相邻的物理存储体中。

![Figure8_5](Figure8_5.png)

给定字的物理存储体取决于字在缓存行内的偏移量（由地址位 [5:2] 给出）和逻辑路径，具体公式如下：

双字的数据缓存数据 RAM 组对 = (缓存路径 + 数据双字偏移量) AND 0x3

字的数据缓存数据 RAM 组 = { ((缓存路径 + 数据双字偏移量) AND 0x3), 地址位 [2] }

下表显示了数据缓存数据 RAM 组的每个条目的位字段，与缓存大小无关。

