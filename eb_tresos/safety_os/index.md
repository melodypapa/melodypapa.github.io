<section id="title">Safety OS</section>

# 1. 背景资料

**EB tresos Safety OS** 是 **AUTOSAR** 标准中 **Os** 模块子集的实现，您可以在需要高安全完整性级别的项目中使用它。

微内核是 **EB tresos** 安全操作系统的一部分，用于管理 **AUTOSAR** 系统的可执行对象。这样管理的可执行对象是由 **AUTOSAR** 标准定义的任务（**Task**）、**ISR** 和hook函数。所有这些对象都作为子程序的执行实例进行管理，在微内核中称为线程。当微内核配置正确时，线程只能修改那些明确允许修改的内存区域。 通过这种方式，微内核提供了不受线程间干扰的空间自由度。

此外，微内核还为标准 **AUTOSAR OS** 的计数器（**counter**）、警报（**alarm**）和调度表（**schedule table**）功能提供接口。微内核也使用线程来管理这个接口，因此可以防止标准操作系统和您自己的可执行对象之间的空间干扰。

出于性能和简单性的原因，微内核被设计为尽可能轻量级。 在某些情况下，它会偏离 **AUTOSAR** 规范。

## 1.1. 任务（Tasks）

任务（**Task**）是可执行的子程序。**EB tresos Safety OS** 使用线程管理任务（**Task**）。优先级会分配给给每个任务（**Task**）。如果多个**Task**任务已经准备好在系统中同时执行，则选择具有最高优先级的任务（**Task**）。这种行为如图 **6.1 Scheduling tasks based on the priority** 所示。具有相同优先级的任务按激活顺序执行。

![Figure6_1](Figure6_1.png)

调度策略控制 **EB tresos** 安全操作系统何时决定接下来应该执行哪个任务。存在两种不同的调度策略：

完全抢占式（**full-preemptive**）

如果具有较高优先级的任务就绪，则立即执行。当前执行的任务被抢占并稍后恢复。这种行为在图 **6.2 Scheduling of fully preemptable tasks** 中进行了描述。

![Figure6_2](Figure6_2.png)

非抢占式（**non-preemptive**）

非抢占式任务继续执行，直到它终止或调用以下服务之一：

* **Schedule()**
* **WaitEvent()** 或 MK_WaitGetClearEvent() 如果事件不存在。

有关 EB tresos Safety OS 如何调度非抢占式任务的信息，请参阅图 **6.3 Scheduling of non-preemptable tasks**。

![Figure6_3](Figure6_3.png)

您可以为每个任务设置调度策略。 图 **6.4 Non-preemptive scheduling policy for a task in EB tresos Studio** 描述了如何使用 EB tresos Studio 配置调度策略。

![Figure6_4](Figure6_4.png)

**AUTOSAR** 为任务（**Task**）定义了以下状态：

* 运行（**RUNNING**）
处理器当前正在执行状态为运行（RUNNING）的任务。在处理器的每个内核上，一次只能有一个任务处于运行（RUNNING）状态。

* 挂起（**SUSPENDED**）
处于挂起（**SUSPENDED**）状态的任务是被动的并且可以被激活。

* 准备就绪（READY）
状态为准备就绪（READY）的任务已准备好可由处理器执行，但另一个任务当前占用了处理器。因此，处于准备就绪（READY）状态的任务需要等待，直到调度程序将处理器分配给它。

* 等待（WAITING）
处于等待（WAITING）状态的任务会一直等待，直到发出事件信号。

在 **EB tresos Safety OS** 中，这些状态不是显式维护的，而是根据线程和任务对象的基础状态按需派生的。

## 1.2. 中断和 ISR

硬件组件可以发出中断信号以表示它们需要注意。要对此类请求采取行动，您可以使用中断服务程序 (ISR)。当处理器接受中断请求时，**EB tresos Safety OS** 会激活中断服务例程。

在 **EB tresos Safety OS** 中，每个 **ISR** 都有两个基本属性：

* 中断源（**interrupt source**）

中断源是一种硬件机制，它将外围设备连接到处理器的中断机制。它允许外围设备向处理器请求服务，并且处理器可以控制发出请求的外围设备的请求。正在运行的处理器被中断以服务中断的过程称为向量化（**vectoring**）。在典型的硬件上，中断源是一个寄存器和向量表（**vector table**）中的一个条目。微控制器手册包含一个中断源列表及其含义。对于 **Cortex-M**，中断源由参数 **OsCORTEXMVector** 配置。有关电源架构（**Power Architecture**）的示例，请参见图 **6.6 ISR configuration in EB tresos Studio**。其他 **CPU** 系列有基本类似。

* 中断级别（**interrupt level**）

中断级别是一个数字，其目的类似于任务（**Task**）的优先级。如果正在执行中断服务程序，并且触发了更高级别的中断源，则处理器接受中断请求并抢占当前正在执行的中断服务程序。中断级别是一个依赖于硬件的值，具体含义取决于硬件。一些硬件定义较高的数值表示较高的级别，而另一些硬件定义较低的数值表示较高的级别。对于 **Cortex-M**，您可以使用选项 **OsCORTEXMIrqLevel** 选择 **ISR** 的中断级别。有关电源架构（**Power Architecture**）的示例，请参见图 **6.6 ISR configuration in EB tresos Studio**。其他 **CPU** 系列有基本类似。

注意，编程到硬件中的数字可能与您选择的值不同。这是因为 **EB tresos Studio** 优化了使用的级别范围。但是顺序是会被保留。

图 **6.5 Execution of ISRs** 描述了 **ISR** 的执行。

![Figure6_5](Figure6_5.png)

有关电源架构（**Power Architecture**）的示例，请参见图 **6.6 ISR configuration in EB tresos Studio**。其他 **CPU** 系列有基本类似。

![Figure6_6](Figure6_6.png)

微内核根据其配置的优先级调度 **ISR**，但在执行时将会将其中断级别编程到硬件中。

中断与任务（**Task**）的执行异步发生。这意味着 **ISR** 可以随时抢占任务（**Task**）。如果您不希望这种行为，您可以暂时禁用中断。

您可以使用服务 **DisableAllInterrupts()** 禁用所有中断，也可以使用 **EnableAllInterrupts()** 重新启用中断处理。图 **6.7 Interrupt locks** 显示了一个示例。

![Figure6_7](Figure6_7.png)

**临界区保护**

如果必须保护临界区免受来自另一个处理器内核的访问，则禁用中断不足以保护多核处理器上的临界区。有关如何实现临界区的更多信息，请参阅第6节，“同步访问公共数据”。

**处理 ISR 类别**

您可以通过配置参数 **OsIsrCategory** 选择从 **AUTOSAR** 已知的中断类别。请注意，**EB tresos Safety OS** 以完全相同的方式处理 1 类和 2 类 **ISR**，即：首先进入微内核，然后如上所述为 **ISR** 启动一个自己的线程。

这两个类别之间的唯一区别是：

* 配置工具强制将 1 类 **ISR** 配置为逻辑上高于任何 2 类 **ISR** 的最高中断级别的中断级别。
* 生成工具为 1 类 **ISR** 的线程生成队列和运行优先级，这些优先级高于任何 2 类 **ISR** 的各自最高优先级。

这些只是源自 **AUTOSAR** 的 **ISR** 类别的初衷的约定。它们旨在为 **EB tresos AutoCore OS** 的配置提供部分交叉兼容性。

作为扩展 **EB tresos Safety OS** 为用户可配置的内部中断（**internal interrupts**）提供了自己的类别，其处理程序不在自己的线程中运行。有关此类别的更多信息，请参阅[内部中断](#121-内部中断)。

### 1.2.1. 内部中断

微内核支持内部中断的概念。内部中断的主要特征是它的处理程序不是在线程中执行，而是直接在内核上下文中执行。它只被内核进入和退出处理的技术上绝对必要的最低限度所包围。内部中断的最初目的是支持需要中断处理的本机内核服务（**native kernel services**），例如：执行预算、时间戳计时器或简单的时间表。出于这个原因，如果您配置了相应的服务并且如果您的衍生产品上的该服务需要它们，则通常会自动生成内部中断的配置。在这些情况下，处理函数作为微内核源代码的一部分提供，不需要您进一步关注。

但是您也可以为自己的目的配置此类内部中断并实现自己的处理程序。为此，您可以按常规方式在 **EB tresos Studio** 中创建 **ISR**，但为参数 **OsIsrCategory** 选择值 **INTERNAL**。如果这样做，除了 **Name**、**OsCORTEXMIrqLevel** 和 **OsCORTEXMVector** 之外的所有配置参数都将毫无意义。如果 **ISR** 是 **INTERNAL**，**EB tresos Studio** 应该将它们中的大多数显示为已禁用或不再可编辑。出于不可避免的技术原因，您必须配置 **OsStacksize**，但您应该将其设置为 **0**，尽管该值同样会被忽略。您可以按照通常的方式将内部中断的 **ISR** 分配给 **OS** 应用程序。这仅在多核环境中有用，因为这将产生的唯一影响是将中断配置为路由到分配应用程序的内核。

如果您以这种方式配置了内部中断，则生成工具会根据您为中断源、级别和内核分配选择的值生成适当的 **IRQ** 配置。它也会生成指向软件中断向量表中的条目，该条目指向具有void OS_ISR_<Name>(void *k, mk_objectid_t p, mk_unsigned_t v) 形式的原型的处理函数。然后，您必须为此标注函数提供一个实现。如果相应的中断发生并导致进入微内核，内核将保存当前上下文并尽可能直接调用该函数，无需进一步的上下文切换、处理器执行状态的更改或内存保护配置的修改。处理函数返回后，微内核可能会选择调度线程，最终恢复传入线程的原始上下文。

如果您使用自己的内部中断，请务必严格遵守以下限制和保留：

* 内部中断处理函数的参数仅供微内核自己的内部处理函数使用。不要使用它们，也不要依赖它们具有一定的价值。
* 请勿从内部处理程序调用任何 **EB tresos Safety OS API**，但 **GetCoreID()** 除外。
* 由于处理程序在内核上下文中运行并且微内核是不可重入的，因此中断被锁定。不要解锁它们。
* 切勿修改内部内核数据结构。如果您的处理程序函数需要一个内存区域，您可以通过通常的方式创建它（参见第 6.8 节，“内存保护”）并使用内核访问对其进行配置。
* 切勿访问专为内核保留的外设的内存映射 **I/O** 区域。如果您需要访问其他外围设备的内存区域，您同样可以通过通常的方式创建内存区域并使用内核访问配置它们。
* 如果访问可能会改变处理器或外围设备的状态，切勿访问专门为微内核保留的专用寄存器。
* 所有内部中断在启动时启用。
* 如果您使用 **EB tresos Safety OS** 生成器来创建您的微内核配置，内部中断的中断级别会受到通常的压缩（如果适用于 CPU 系列）。但是，它们的级别不受锁定级别的计算。因此，没有任何通用的方法可以通过任何微内核的 API 来启用或禁用来自其他可运行实体的内部中断。当且仅当其配置的级别小于或等于适当 ISR 的最高级别时，将中断锁定到该级别的 API 也会锁定内部中断。这也适用于适当的 ISR 被其级别锁定的其他情况，例如在错误hook中运行时。
* 微内核的专有 API MK_DisableInterruptSource() 和 MK_EnableInterruptSource() 不适用于内部中断。
* 当其各自拥有的 OS 应用程序终止时，不会禁用用户配置的内部中断。

您可以在 **EB tresos Safety OS** 安全手册 **CORTEXM** 系列 [SAFETYMANCORTEXM] 中找到有关专有外设和寄存器的更多信息，以及详细的安全要求和限制，特别是在 CPU 系列的补充中，以及处理callout功能。有关如何手动配置内部中断的更多信息，另请参见第 8.4.1 节，“系统范围的配置宏”，尤其是。 MK_SOFTVECTOR_nnnn 的条目和第 8.4.5 节，“中断源的配置”。

**使用内部中断**

由于内部中断完全在内核上下文中运行，因此所有内核数据和外围设备都暴露给它们。同时他们通常还有权修改 **MCU** 中的几乎所有内容，错误的内部中断处理程序可能会导致 **EB tresos Safety OS** 未定义的行为。用户配置的内部中断处理程序必须被评估为系统的最高安全完整性级别，以确保它们不会对内核数据或外围设备执行任何不利的访问。

如果您可以绝对确保用户定义的内部中断处理程序不会对微内核的状态产生不利影响，则才可以被使用。相反，您应该尽可能尝试使用正确的第 1 类或第 2 类 **ISR**。

## 1.3. 受信任函数

受信任函数通常是由应用程序提供的服务，与调用任务（**Task**）或 **ISR** 相比，它们需要使用自己的处理器模式和内存保护设置运行。

### 1.3.1. 受信任函数简介

受信任的函数是可执行的子程序，它们不能在调用者的环境中执行，因为它们需要额外的权限或通常需要特殊的环境。示例是需要在主管模式下运行的功能，例如：执行硬件访问或需要对调用者没有的特殊内存区域进行写访问。

每个受信任函数都有一个配置的处理器模式。在该模式下启动它，并且可以有自己的内存保护配置。此外它被分配给某个核心，并且只能在多核系统中在该核心上被调用。

当应用程序通过 CallTrustedFunction() 调用受信任函数时，如果调用内核上没有其他受信任函数已运行，则在微内核中会发生以下行为：

1. 微内核激活受信任函数线程，这是一个执行受信任函数的特殊线程。设置优先级以便线程在调用者的线程之前。处理器模式和内存保护设置设置为受信任功能配置的设置。
2. 微内核抢占调用者的执行，执行受信任函数线程。在那环境中使用提供给 CallTrustedFunction() 调用的参数执行请求的受信任函数。
3. 当受信任函数结束时，受信任函数线程也会一并结束，微内核将控制权交还给调用者。

这种行为如图 **6.8 Execution of a trusted function** 所示。

![Figure6_8](Figure6_8.png)

如果调用了一个受信任函数并且该受信任函数线程已经被另一个受信任函数占用，则行为变化如下：

1. 微内核将受信任函数加入到受信任函数线程队列中，然后它会提高受信任函数线程的优先级，以便它在调用者的线程之前。

2. 微内核抢占调用者的执行，继续受信任的函数线程。在那里，当前受信任的功能以及所有排队的功能都使用正确的设置和参数执行。这意味着，例如处理器模式和内存设置适用于线程中执行的每个受信任函数。

3. 当队列为空时，受信任函数线程结束，微内核将控制权交还给具有最高优先级的受信任函数调用者。由于受信任函数线程已被占用，因此有多个调用者。

在每种情况下，当控制权转移回受信任函数的调用者时，该受信任函数在该点被执行并结束。

### 1.3.2. 受信任功能的配置和使用

如果您想在 **EB tresos Safety OS** 中使用受信任函数，您可以使用 **EB tresos Studio** 在配置容器 /Os/OsApplication/OsApplicationTrustedFunction 中配置受信任函数。您可以在那里配置受信任函数本身，包括受信任函数特定的内存区域、处理器模式、必要的堆栈大小和其他属性。

在您的应用程序代码中，调用服务 CallTrustedFunction() 以调用受信任函数。第一个参数是函数索引。这是受信任函数配置列表**MK_CFG_TRUSTEDFUNCTIONLIST**中对应函数的索引。如果您使用 **EB tresos Studio** 生成基本配置，您可以在文件 **Mk_gen_user.h** 中找到带有受信任函数名称的常量，您可以将其用作函数索引。

## 1.4. 与 QM-OS 的交互

微内核并未实现 **AUTOSAR** 定义的所有 **API** 服务。具有完整性类别3（**integrity category 3**）的 **API** 服务由 **QM-OS** 实现。具有完整性类别2（**integrity category 2**） 的 **API** 服务在微内核中实现了一个包装器，该包装器在称为 **QM-OS** 线程的特殊线程中执行相应的 **QM-OS** 服务。 有关完整性类别的更多信息，请参阅 [SAFETYMANCORTEXM]。

### 1.4.1. 完整性类别2的服务

具有完整性类别2的服务是由 **QM-OS** 实现，但在微内核中有一个包装器以确保不受数据域干扰的服务。为了做到这一点，微内核包装器启动一个特殊的线程，**QM-OS** 线程并在这个线程中执行 **QM-OS** 服务。 图 **6.9 Execution of a QM-OS service** 显示了完整性类别 2 服务的处理。

![Figure6_9](Figure6_9.png)

完整性类别 2 服务的处理类似于可信功能的处理，如图 **6.8 Execution of a trusted function** 所示。

如果您使用 **EB tresos Studio** 配置微内核，**QM-OS** 线程会自动访问必要的内存区域并具有适当的处理器模式。除此之外，您可以在设置要添加的内存区域的参数 /Os/OsMicrokernel/MkMemoryProtection/MkMemoryRegion/MkMemoryRegionOsThreadAccess 时向线程添加对更多内存区域的访问。您还可以使用参数 /Os/OsMicrokernel/MkThreadCustomization/MkOsThreadMode 更改线程处理器模式，但您不应该这样做。

完整性类别 2 的服务在第 8.2 节 微内核 API 参考 中标记为 **MK/OS**。

### 1.4.2. 完整性类别3的服务

具有完整性类别 3 的服务是由 **QM-OS** 实现的服务，无需微内核任何附件功能。它们直接在调用者的上下文中执行，并且不像完整性类别 1 和 2 服务那样提供不受干扰的自由。因此，如果在 **ASIL** 分区中使用此类服务，调用者必须采取适当的措施。

如果您使用 **EB tresos Studio** 配置微内核，任务（**Task**）和 ISR 会自动访问必要的内存区域。因此，您无需在 **EB tresos Studio** 中显式配置任何内容。

完整性类别 3 的服务在第 8.2 节 微内核 API 参考 中标记为 **OS**。

## 1.5. 多核运行

微内核能够在多核处理器的两个或更多核上同时执行。当微内核配置为多核操作时，针对 **OS** 对象的静态内核分配的 **AUTOSAR** 概念允许微内核独立于其他内核操作每个内核。为任务（**Task**）和 **ISR** 所描述的调度机制会独立应用于每个内核上。

内核间请求通过消息传递执行，因此在目标对象配置为运行的内核上进行处理。这种机制避免了微内核内部对内核间同步锁的需要。

### 1.5.1. 内核索引和物理内核的映射

**AUTOSAR** 区分物理内核ID和逻辑内核ID。微内核使用类似于但不等于 **AUTOSAR** **CoreID** 的逻辑核心索引。这些核心索引从值 **0** 开始编号，一直编到 **MK_MAXCORES - 1** 的值，这取决于硬件。有关逻辑内核索引及其到物理内核的映射的更多信息，请参阅第 9.12 节，Cortex-M 处理器上的多核支持。

逻辑内核索引在软件中用作参数以及在配置中用于识别不同的核心。

如果启用了高级逻辑内核标识符，则可以配置与上述默认映射不同的核心映射。您可以在 [ASCOS_USERGUIDE]中找到有关此主题的更多信息。

**负内核索引**

一些微内核服务需要核心索引作为参数。除了硬件支持的逻辑核心索引之外，这些服务还允许负值作为核心索引。负核心索引将被这些服务将解释为当前核心。

这个处理被几个微内核服务用来为当前核心提供一个简单版本的服务。例如，对 MK_GetPanicReasonForCore(-1) 的调用与 MK_GetPanicReasonForCore(i) 的行为方式相同，其中 i 是当前核心的内核索引，也与 MK_GetPanicReason() 的方式相同。

### 1.5.2. 内核间通信

您可以从任何内核请求任务激活（**task activations**）、事件设置（**event settings**）和 QM-OS 服务（**QM-OS services**），而不管目标对象配置为哪个内核。微内核提供了两种机制来处理内核间请求：

#### 1.5.2.1. 同步内核间请求（Synchronous inter-core requests）**

同步内核间请求是一种用于触发另一个内核上的工作并需要返回该工作结果的服务的机制。一个示例是 API **ActivateTask()**，如果它被分配给与调用它的内核不同的内核的任务调用它。

在这种情况下，微内核执行以下操作：

![](2022-08-31-17-46-40.png)

源内核（**Source core**）标识为调用 **API** 服务的内核。目标内核（**Target core**）标识为必须在其上执行 **API** 功能的内核，例如：任务运行的内核，他需要被 **ActivateTask()** 调用激活。

信号是通过内核间中断（**inter-core interrupts**）完成的，这些中断在分配给它们的所有已使用中断中具有最高优先级。通过这种方式设置优先级，以便这些中断不会被任何中断锁定 API 锁定，尤其是包括 **SuspendAllInterrupts()** 和 **DisableAllInterrupts()**。如果您使用 **EB tresos Studio** 进行配置，则无需配置这些中断。如果您手动配置微内核，您可以在第 9.12 节 **Cortex-M 处理器上的多核支持** 中找到有关内核间中断的更多信息。

**向错误hook报告错误**

如果在执行包含对另一个内核的请求的 API 期间识别出错误，则识别错误的内核是需将错误报告给错误挂钩（**error hook**）的内核。另一个内核不向错误挂钩报告错误。与在何处识别错误无关，如果存在与错误对应的返回值，则将该返回值返回给调用者。

示例：如果使用无效的任务（**Task**） ID 调用 ActivateTask()，则该错误已在源内核上已经识别出来，所以源内核也会报告给错误挂钩。如果在另一边，任务 ID 是有效的，但新任务激活超过了激活计数器，这将在目标内核上识别并报告给那里的错误hook。

#### 1.5.2.2. 异步内核间请求（Asynchronous inter-core requests）**

同步的内核间请求在 **CPU** 时间上是昂贵的。因此微内核通过添加一组异步发后不理（**fire and forget**） API 来扩展 **AUTOSAR API** 以处理内核间请求。如果满足参数的静态可验证条件，例如：通过范围检查，在消息为目标核心排队后，立即将结果代码 **E_OK** 返回给调用者。如果检测到诸如 **E_OS_LIMIT** 之类的动态错误，则通过 **ErrorHook()** 函数进行报告。然而，调用者将不会被通知到。

异步 API 可用于所有对象，即使是与调用者在同一内核心的对象。对于同一内核上的微内核对象，异步调用被转换为同步调用。但是，如果调用者运行在一个高优先级，对 **QM-OS** 服务的异步调用可以会被加入队列并稍后执行。

您可以通过名称来识别异步 API。它们以前缀 **MK_** 开头，因为它们是特定于微内核的函数，后跟 **Async** 表示异步，并以 **AUTOSAR API** 名称结尾。 **MK_AsyncActivateTask()** 是 **ActivateTask()** 的异步版本。

## 1.6. 同步访问公共数据

在多任务环境中，任务（**Task**）和 **ISR** 通常共享对大量物理资源和系统资源的访问。在 **EB tresos Safety OS** 中，锁（**locks**）提供了一种协调对共享数据的并发访问的方法。微内核的锁机制实现了由 AUTOSAR 资源（**AUTOSAR resources**）、中断锁（**interrupt locks**）和自旋锁（**spinlocks**）指定的所有协调机制。同时也包括由资源和自旋锁组合而成的特定的 EB 供应商的锁（**EB-vendor-specific lock**）。

### 1.6.1. 资源

**AUTOSAR** 将资源(**Resource**) 指定为用于同步在同一内核上（**on the same core**）执行的**Task**任务和 **ISR** 的机制。资源没有死锁（**deadlock**）和优先级倒置（**priority inversion**）。

#### 1.6.1.1. 死锁预防

当一个**Task**任务或 **ISR** 尝试获取已被第二个**Task**任务或 **ISR** 占用的锁，而第二个**Task**任务或 **ISR** 等待获取已被第一个**Task**任务或 **ISR** 占用的锁时，就会发生死锁。**OSEK/VDX** 资源对象通过施加一组限制来防止死锁情况：

* 只有当所有资源都可用时，**Task**任务或 **ISR** 才会从 **READY** 过渡到 **RUNNING**。
* **Task**任务或 **ISR** 在持有资源时不能终止，也不能进入 **WAITING** 状态。
* 必须按照 **LIFO**（后进先出）顺序获取和释放多个资源。 这意味着每个 **Task**任务或 **ISR** 在逻辑上管理它在堆栈上所需的资源。
* **Task**任务或 **ISR** 不得尝试获取其已拥有的资源。

#### 1.6.1.2. 优先级反转

当高优先级**Task**任务 (TH) 被迫无限期地等待低优先级**Task**任务 (TL) 完成时，就会出现优先级反转。当 TL 持有 TH 所需的锁时，就会出现这种情况。TH 在获得锁之前不会进入 RUNNING 状态。在 TL 释放它之前，锁不可用。虽然TL持有锁的执行时间是有限的，但是任何优先级在TL和TH之间的Task（TM）都可以抢占TL，阻止它释放锁。这种行为可能发生无数次，可能是由几个不同的 TM 任务造成的，因此会在不确定的时间内延迟 TH 的执行。

为防止出现这种情况，**EB tresos Studio** 确定使用资源的所有**Task**任务 或 **ISR** 的最高优先级。此优先级称为资源的上限优先级。每当**Task**任务 或 **ISR** 获取资源时，**Task**任务 或 **ISR** 的优先级设置为计算的上限优先级。当资源被释放时，旧的优先级又恢复了。这种方法称为 **OSEK/VDX** 优先级上限协议（**priority ceiling protocol**）。或在某些文献中被称为优先级上限仿真协议（**priority ceiling emulation protocol**）。

该协议确保在**Task**任务 TL 持有资源时，不会执行优先级低于**Task**任务 TH 的 **Task**任务。**Task**任务 TL 优先执行，直到它释放其资源的那一刻，从而使**Task**任务 TH 变为 RUNNING 状态。

#### 1.6.1.3. 资源的配置和使用

如果您想在 **EB tresos Safety OS** 中使用资源，**EB tresos Studio** 可以轻松配置它：

1. 如图 **6.10 Resource configuration in EB tresos Studio** 所示，创建资源。

![Figure6_10](Figure6_10.png)

2. 为每个使用资源的任务（**Task**）和 ISR 配置对资源的引用，请参见图 **6.11 Referencing a resource in EB tresos Studio**。

![Figure6_11](Figure6_11.png)

在您的应用程序代码中，调用服务 GetResource() 以获取资源，并调用 ReleaseResource() 以在临界区之后释放它。 图 **6.12 Resources** 中描述了此过程的一个示例。

![](2022-08-31-18-45-37.png)

### 1.6.2. 调度程序资源（The scheduler resource）

OSEK/VDX 将调度程序资源 (**RES_SCHEDULER**) 指定为由所有任务隐式共享的资源，而无需为每个任务显式配置它。 **AUTOSAR** 规范的最新版本省略了 **RES_SCHEDULER**，但 **EB tresos Studio** 和微内核保留了对向后兼容性的支持。

在多核环境中，每个配置的核都有自己的 **RES_SCHEDULER** 的副本（**own cooy**）。因此在特定内核上的任务中调用 **GetResource(RES_SCHEDULER)** 会阻止该核心上的所有其他任务运行，直到 **RES_SCHEDULER** 再次被释放。

### 1.6.3. 中断锁（Interrupt locks）

中断锁定是防止更高优先级任务或 ISR 在同一内核（**on the same core**）上执行的便捷方式。

#### 1.6.3.1. 介绍

AUTOSAR 使用微内核支持的相关 API 指定了几种不同的中断锁类型：
* 锁定所有类别1的和类别2的中断：如果需要嵌套，则为 **SuspendAllInterrupts()** 和 **ResumeAllInterrupts()**；如果不需要嵌套，则为 **DisableAllInterrupts()** 和 **EnableAllInterrupts()**。
* 锁定类别2的中断：**SuspendOsInterrupts()**、**ResumeOsInterrupts()**。

虽然 **DisableAllInterrupts()** 和 **EnableAllInterrupts()** 服务只是启用或禁用中断，但其他中断锁服务会存储先前的锁定状态并使用获取计数器（**acquisition counter**）。这意味着第一个 **SuspendXxxInterrupts()** 调用存储当前的中断锁定状态，禁用相应的中断并增加采集计数器。对同一服务的进一步调用不会更改中断锁，而只会增加获取计数器。服务 **ResumeXxxInterrupts()** 递减获取计数器。它最终会恢复存储的中断锁状态，但前提是获取计数器达到**0**。否则它保持中断锁不变。

两组 **Suspend/ResumeAllInterrupts()** 和 **Suspend/ResumeOsInterrupts()** 有自己独立的采集计数器。

#### 1.6.3.2. 中断锁的配置和使用

如果要使用中断锁，并不需在 **EB tresos Safety OS** 中进行配置。只需在您的应用程序中使用相应的服务。

不要混淆 **Suspend/Disable** 和 **Resume/Enable** 服务以及不同锁类型的 **Suspend** 和 **Resume** 服务。如果你使用例如 **SuspendAllInterrupts()** 获取中断锁，使用 **ResumeAllInterrupts()** 再次释放。

同时也不要嵌套在另一个中断锁中使用 **DisableAllInterrupts()/EnableAllInterrupts()**。

**使用资源而不是中断锁**

您不应该使用中断锁，而是需使用资源来代替。与微内核中的资源相比，中断锁没有性能优势，并且资源可以达到比中断锁更精细的保护粒度。

### 1.6.4. 自旋锁（Spinlocks）

自旋锁是一种在多核环境中同步运行在不同核上（**on different cores**）的任务的机制。顾名思义，等待自旋锁是一个忙等待（**busy-waiting**）的活动。

#### 1.6.4.1. 自旋锁的配置和使用

**AUTOSAR** 指定了自旋锁机制和相关的 **API**，允许任务（**Task**）和 ISR 使用配置的自旋锁。微内核中的自旋锁实现基于 **AUTOSAR** 规范。

如果您想在 **EB tresos Safety OS** 中使用自旋锁，您可以通过创建自旋锁来实现，即 **EB tresos Studio** 中的 **Os/OsSpinlock** 容器。

在您的应用程序代码中，调用服务 **GetSpinlock()** 或 **TryToGetSpinlock()** 来获取自旋锁，并调用 **ReleaseSpinlock()** 来释放它。

#### 1.6.4.2. 死锁预防

自旋锁不是没有死锁的，可能会发生死锁。例如：如果两个内核想要使用相同的两个自旋锁，但使用不同的序列来获取它们。虽然第一个内核获得了自旋锁 **sp1**，现在尝试获得自旋锁 **sp2**，但第二个内核已经可以获得 **sp2**，现在尝试获得 **sp1**。在注意防止这种死锁之前，两个核心都无法继续。

自旋锁也不会阻塞与调用者在同一内核上的任务（**Task**）。例如：如果获得自旋锁的任务（**Task**），被同样需要该自旋锁的更高优先级任务（**Task**）抢占，则更高优先级任务将永远自旋以获取锁，并且形成死锁。

**AUTOSAR** 定义了一些机制和 API 返回值来防止这种死锁。 然而微内核并没有实现任何这样的机制。应用程序必须确保以某种方式使用自旋锁，以免发生死锁。

如何防止死锁取决于应用程序本身。 以下提示是一个很好的起点：

* 如果需要多个自旋锁，请始终以相同的顺序获取自旋锁。
* 如果一个自旋锁被同一个核心上具有不同优先级的多个可抢占任务使用，则将使用自旋锁的部分封装到适当的临界区中，例如：通过使用资源。

### 1.6.5. 组合锁

微内核提供了一种特定于 EB 供应商（**EB-vendor-specific**）的机制的锁，可以称之为组合锁（**combined lock**）。它本质上是自旋锁（**spinlock**）与内核本地锁（**a core local lock**）的一种组合，其行为类似于中断锁（**interrupt lock**）或者资源（**resource**）。

除了其正常的自旋锁属性外，这种组合锁还有一个上限优先级（**a ceiling priority**）和一个中断锁级别（**an interrupt lock level**）。当这样的锁被成功获取时，调用者的优先级被提升到上限的优先级，中断锁级别被提升到组合锁的锁级别，并且获得自旋锁。这种行为有效地防止了其他优先级低于上限优先级的任务（**Task**）和低于锁定级别的中断被执行。

如果锁获取失败或者**API**返回重试状态（即：返回值为**MK_E_TRYAGAIN**）时，则优先级和锁级别保持不变。锁的任何部分都没有被获得占用。

#### 1.6.5.1. 组合锁的配置和使用

如果您想在 **EB tresos Safety OS** 中使用组合锁，您可以在 **EB tresos Studio** 中通过创建自旋锁（即：**Os/OsSpinlock** 容器）并将 **Os/OsSpinlock/OsSpinlockLockMethod** 参数更改为预定义的组合锁的配置值来执行此操作：
* **LOCK_NOTHING**：标准自旋锁。
* **LOCK_ALL_INTERRUPTS**: 一种组合锁，自旋锁外加针对所有中断的中断锁。
* **LOCK_CAT2_INTERRUPT**：一种组合锁：自旋锁外加针对所有2类中断的中断锁。
* **LOCK_WITH_RES_SCHEDULER**：一种组合锁：自旋锁加一个类似于获取 **RES_SCHEDULER** 的锁。有关更多信息，另请参阅第 6.6.2 节，调度程序资源。

您还可以手动配置具有单独的上限优先级和锁定级别的组合锁。有关更多信息，另请参阅第 8.4.11 节，锁的配置。

在您的应用程序代码中，调用服务 GetSpinlock() 或 TryToGetSpinlock() 以获取组合锁，并调用 ReleaseSpinlock() 以释放它，就像您将它们用于自旋锁一样。

**注释：**

* 如果除了自旋锁之外还需要本地锁，则组合锁可以减少微内核开销。
* 组合锁具有类似于第 6.6.3 节中断锁（**Interrupt locks**）的获取计数器。如果您多次获取组合锁，则在第一次调用时获取锁，并且获取计数器设置为 1。进一步获取只会增加获取计数器。当组合锁被释放时，每次释放时获取计数器都会递减。只有当它再次达到 0 时，锁才真正被释放。

#### 1.6.5.2. 死锁预防

组合锁不是没有死锁的。只要选择了适当的组合锁，上述自旋锁中已知的抢占任务的死锁场景就不再适用了。例如：**LOCK_ALL_INTERRUPTS** 来有效地防止了任务抢占。但是一下其他场景，例如来自自旋锁部分的多个锁的场景仍然存在。有关更多信息，可请参阅第 6.6.4.2 节，预防死锁。

因此与自旋锁一样，应用程序必须确保以某种方式使用自旋锁，不会发生死锁。

## 1.7. 事件

在嵌入式系统中，通常需要通知任务（**Task**）状态转换或其他特殊事件。事件就是一种实现此类通知的机制。

事件是分配给任意扩展任务（**Task**）的专有信号。您可以将多个事件分配给同一任务（**Task**）。一个任务（**Task**）可能会等待一个或多个事件，从而进入 **WAITING** 的状态。任何任务（**Task**）都可以为任意任务（**Task**）设置事件。如果接收任务（**Task**）至少需等待这些事件中的某一个事件，则设置事件会导致接收任务（**Task**）进入 **READY** 的状态。

图 **6.13 Events** 显示了如何利用事件的示例性行为。

![Figure6_13](Figure6_13.png)

## 1.8. 内存保护

AUTOSAR 兼容的操作系统的内存保护边界基于OS对象（**OS-objects**）和OS应用程序（**OSApplications**）：每个 OS 对象都有自己的堆栈内存区域和私有数据（**private data**）的内存区域。此外每个应用程序都存在一块共享区域。您可以使用驻留在此共享区域中的变量在应用程序的OS对象之间交换信息。这种类型的配置如图 **6.14 Memory protection boundaries based on OS-Applications** 所示。

![Figure6_14](Figure6_14.png)

当您在 **EB tresos Studio** 中将任务（**Task**）和 ISR 分配给OS应用程序时，会自动创建内存保护配置。

**OS应用程序的内存保护配置** 

将所有OS应用程序的 **OsTrusted** 选项配置为 **FALSE**。否则，OS应用程序的对象将获得额外的内存访问权限。

### 1.8.1. 细粒度内存区域控制

除了上述内存保护配置之外，**EB tresos Safety OS** 还提供了对不同内存区域及其与**OS对象**关联的非常精细的控制。您可以配置额外的内存区域并将这些内存区域与**任务（**Task**）**和**ISR**相关联。

有关如何使用 **EB tresos Studio** 配置附加内存区域的信息，请参见图 **6.15 Configuration of additional memory regions with EB tresos Studio**。

![Figure6_15](Figure6_15.png)

有关如何将内存区域添加到任务（**Task**）的信息，请参见图 **6.16 Referencing a memory region within a task in EB tresos Studio**。

![Figure6_16](Figure6_16.png)

### 1.8.2. 例子

您可以将内存保护配置的细粒度控制用于不同目的。本节展示了两个典型的用例。

#### 1.8.2.1. 限制对外围设备的访问

通常希望将对外设的访问限制在选定的os对象上。如果外设的输入/输出空间是内存映射的，则可以通过使用内存地址空间的专用部分来访问外设，这样也就可以使用内存保护的方式来限制对选定外设的访问。

为了达到此目的，可创建一块专用的内存区域，通过该区域来引用相关外设的内存映射 **IO** 空间。在选定的OS对象中引用此内存区域，并确保没有其他内存区域允许访问此外设。

**对OS对象的附加规定**

依赖于微控制器（**microcontroller**）和外围设备（**peripheral**），可能会需要一些附加的规定。例如：在特权模式（**privileged mode**）下执行 OS 对象。在本示例暂且假定非特权模式已经足够。同时一些其他硬件机制（如：外围设备的保护）可能能够提供额外的保护，并且可能需要独立于本示例进行额外的配置。

### 1.8.3. 在操作系统对象之间交换数据

您可以使用分配给不同OS对象的共享内存区域进行交换数据。执行此操作时，您必须确保数据的一致性。

如果数据有一个发送端（**source**）和一个接收端（**sink**），一个非常适合的方法是生产者-消费者（**producer-consumer**）设计模式。 一个OS对象充当生产者并将数据生成到共享区域中，而消费者则从共享区域读取数据并进一步处理。

您必须考虑生产者-消费者设计模式的两个特殊性：

1. 生产者和消费者共享的内存必须映射到内存区域。
2. 共享数据必须保持一致，例如：使用某种形式的同步。

#### 1.8.3.1. 访问权限

要将数据映射到内存区域，您必须首先知道如何访问数据。生产者-消费者模式适用于以下访问方案：
* 生产者将数据写入共享区域。
* 消费者从共享区域读取数据。

特别是，消费者是不需要对共享区域的内容进行写访问。

**数据确认**

如果消费者需要与生产者通信，您可以使用消费者可写且生产者只读的内存区域。如果消息足够小，使用单个Bit位即可容纳下，则可以使用事件来代替。有关详细信息，请参阅[第1.7节事件](#17-事件)。

有关如何将此访问方案映射到内存区域的信息，请参见图 **6.17 Using memory regions to share data**。

* 一块内存区域被生产者所引用。该区域的访问权限被设置为读/写（**read/write**）。
* 另一个内存区域被具有只读访问权限的消费者所引用。
 
两个区域都引用相同的地址范围，仅在各自的访问权限上有所不同。

![Figure6_17](Figure6_17.png)

**RAM 读访问**

您可能希望使用一个被所有OS对象所共享的区域，并授予对整个**RAM**的读取访问权限。在这种情况下，消费者不需要不同的内存区域。**EB tresos Studio**会自动生成这样一个区域，请参阅第 7.4.2.9.3 节 使用 EB tresos Studio 时的内存区域 中的 **MK_GlobalRam**

#### 1.8.3.2. 数据一致性

有几种机制可以使消费者和生产者之间的数据保持一致：

* 您可以使用锁（**locks**）来实现生产者和消费者的互斥。
* 您可以使用适当的调度设置（**appropriate scheduling settings**）来保证生产者和消费者的互斥。
* 即使从生产者和消费者并行访问，您也可以使用提供一致视图的数据结构（**data structures**）和访问模式（**access patterns**）。本示例部分未对此方法进行描述。

**使用锁实现互斥**

锁（**Lock**）是一个占位符，涵盖了可用于确保互斥的几种不同机制。这些机制包括资源（**resources**）、中断锁（**interrupt locks**）、自旋锁（**spinlocks**）和组合锁（**combined locks**）。有关更多信息，另请参阅[第6.6节 同步访问公共数据](#16-同步访问公共数据)。

这些机制中的每一个都有自己的应用领域，您必须适当地选择它们。

* 如果生产者和消费者在同一个核上，即：在单核系统和多核系统中同一个核，则使用资源和中断锁。
* 如果将生产者和消费者分配到不同的内核，则使用自旋锁。
* 组合锁适用于分布在多个内核或者同一内核上的多个生产者和/或消费者的情况。

当在使用锁是，需为生产者和消费者配置适当的锁。

* 在访问临界区之前，调用相应的锁获取函数，例如：在使用资源的情况下，调用GetResource() 。
* 在离开临界区之后，调用相应的锁释放函数，例如：在使用资源的情况下，调用ReleaseResource()。

这样可以保证生产者和消费者不能同时进入临界区。

**使用适当的调度设置来保证生产者和消费者的互斥**

在以下的情况下，因为避免了生产者和消费者对共享数据的伪并行访问，所以可以使用此方法:

* 如果生产者和消费者都是任务（**Task**），并且这些任务分配给同一个内核。
* 如果两个任务都被标记为非抢占，它们不能异步抢占对方。 
* 如果两个任务都选择了相同的调度优先级，它们根本不能互相抢占。

推荐使用锁来解决互斥问题，因为这样提供了更好的代码可维护性。可以将锁限制在临界区，每个场景都有锁，尤其是多核系统中的临界区。另一方面，可以通过使用调度设置（**scheduling settings**），来提高运行性能，因为调度设置不需要系统调用。

## 1.9. 时序保护

要在符合 AUTOSAR 的操作系统中实施时序保护，需限制分配给每个任务（**Task**）或 ISR 的执行时间。为此需强制执行两个限制：

1. 每次调用任务（**Task**）或 ISR 的执行时间。
2. 每个任务（**Task**）或 ISR 的激活频率。

目的是保证有足够的可用处理器时间来满足所有实时期限。然而，这种保证所需的调度分析并非易事。

此外仅这些限制不足以确保系统正确运行，因为没有机制可以对激活频率应用一个最低下限。出于这个原因，在许多情况下最终期限监控（**deadline monitoring**）优于 AUTOSAR 时序保护。

尽管如此，微内核还是为 AUTOSAR 时序保护提供了一些支持。微内核还提供了一些低级服务，可以使用这些服务来构建其他形式的时序保护。微内核提供的时序保护功能包括时间服务（time **services**）和执行预算监控（**execution budget monitoring**）。有关详细信息，请参阅[第6.9.1节时间服务](#191-时间服务)和[第6.9.2节执行时间预算](#192-执行时间预算)。

### 1.9.1. 时间服务

微内核的时间服务基于一个长持续时间(**long-duration**)的计时器，该计时器要么由硬件直接提供，要么来源于较短持续时间的硬件计时器。通过长持续时间计时器测量的持续时间是经过设计的，因此永远不必考虑计时器溢出的影响。

为实现此功能，微内核使用**mk_time_t**的64位的数据类型来操作原始时间值。数据类型在参考部分中进行描述。

当您处理较短的时间间隔时，使用**32**位的数据类型通常更方便。为此，微内核也使用**mk_unit32_t**的基本无符号整数类型。

微内核提供了一组服务，您可以使用它们来获取时间并使用绝对时间（**absolute time**）和时间间隔（**intervals of time**）。这些服务在以下段落中，进行了简要的描述，在第 8.2 节微内核API参考中进行了详细描述。您可以从以任何处理器模式运行的线程调用所有这些服务。不需要特殊特权。

**MK_ReadTime** 

为了访问原始计时器值，微内核提供服务**MK_ReadTime**。通过调用此服务获得的时间值可以被视为在过去某个时间从零开始。它们会不断增加，直到下次重新启动系统。定时器的确切范围取决于硬件及其配置，请参见**第9.7节Cortex-M 处理器上的定时器**。

**MK_DiffTime** 

为了计算两次之间的64位差异，微内核提供了服务 **MK_DiffTime**。

**MK_ElapsedTime** 

为了获取自给定时间以来经过的时间，微内核提供服务 **MK_ElapsedTime**。此服务结合 **MK_ReadTime** 和 **MK_DiffTime** 并更新给定时间，以便使用相同变量的重复调用返回调用之间经过的时间。

**MK_DiffTime32** 

为了计算两次之间的32位差异，微内核提供了服务 **MK_DiffTime32**。此服务提供的值在最大可能值处饱和。因此，当您监视事件之间的时间时，您不能将超出允许限制的长持续时间与在允许限制内的短持续时间混淆。

**MK_ElapsedTime32** 

为了获取自给定时间以来经过的时间，微内核提供服务 **MK_ElapsedTime32**。此服务结合 **MK_ReadTime** **和 MK_DiffTime32** 并更新给定时间，以便使用相同变量的重复调用返回调用之间经过的时间。

除了上述服务之外，微内核还提供以下旧的便利服务以实现兼容性：

* MK_ElapsedMicroseconds
* MK_ElapsedTime1u
* MK_ElapsedTime10u
* MK_ElapsedTime100u

**溢出保护**

服务 **MK_ElapsedMicroseconds**、**MK_ElapsedTime1u**、**MK_ElapsedTime10u** 和 **MK_ElapsedTime100u** 已弃用且不提供溢出保护。请改用 **MK_ElapsedTime** 或 **MK_ElapsedTime32**。

微内核提供了转换宏，您可以使用这些宏在计时器滴答和纳秒之间进行转换。

### 1.9.2. 执行时间预算

您可以为您在微内核中配置的所有线程提供执行时间预算。预算指定线程单次调用线程可以占用处理器的最长时间，其中调用定义为激活或成功调用 **WaitEvent** 或 **MK_WaitGetClearEvent**。

微内核仅根据线程预算计算线程实际占用 **CPU** 的时间。等待 **CPU** 所花费的时间（例如：当更高优先级的线程正在运行时）不计算在内。这意味着花在受信函数（**trusted functions**）或调用 QM-OS 服务上的时间不计入调用者的执行预算。

如果线程的执行预算在以下情况之前到期，则微内核报告保护错误，从而导致调用保护hook。

* 线程终止（**thread terminates**）。
* 调用 **WaitEvent()** 。
* 调用 **MK_WaitGetClearEvent()** 。

没有与执行预算相关的微内核服务。

### 1.9.3. 时间换算

微内核提供了宏和函数，用于在以纳秒为单位指定的时间值和在一系列常用频率下运行的时钟的等效滴答值之间进行转换。

您可以在头文件 **Mk_timeconversion.h** 中找到可以转换的频率。本节只涉及一些一般模式。

对于每个支持的频率f，微内核定义了四个宏：

**MK_NsToTicks_f(ns)** 

将参数 ns 纳秒转换为给定频率下的等效滴答数，而不会在中间计算中溢出。该宏可以在编译时进行评估，因此您可以使用它来初始化常量。

**MK_TicksToNs_f(tk)**

将给定频率的参数 tk 滴答值转换为等效的纳秒数，中间计算不会溢出。如果结果值太大而无法用32位无符号数表示，则宏计算为0xffffffff。该宏可以在编译时进行评估，因此您可以使用它来初始化常量。

**MK_NsToTicksF_f(ns)**

将参数 ns 纳秒转换为给定频率下的等效滴答数，而不会在中间计算中溢出。该宏可能使用 **MK_MulDiv** 函数来获得更好的范围和精度，因此不能保证在编译时进行评估。

**MK_TicksToNsF_f(tk)**

将给定频率的参数 tk 滴答值转换为等效的纳秒数，中间计算不会溢出。如果结果值太大而无法用32位无符号数表示，则宏计算为0xffffffff。该宏可能会使用 **MK_MulDiv** 函数以获得更好的范围和精度。因此它不能保证在编译时进行评估。

在编译时使用 **32** 位无符号算术进行评估而不会溢出的要求意味着宏 **MK_NsToTicks_f** 和 **MK_TicksToNs_f** 可能会在中间计算中引入舍入误差。错误通常发生在不是整数的输入值上，例如 **10** 或 **100** 的倍数。微内核的实现试图最小化这些错误。然而当它处理设计无法预测的值时，例如：要将运行时获得的刻度值转换为纳秒，您可能更喜欢使用 **MK_NsToTicksF_f** 或 **MK_TicksToNsF_f**，这会以更少的执行时间为代价提供更好的准确性。

## 1.10. API访问保护

微内核为以下 **API** 提供访问保护机制：

* ShutdownOs()
* ShutdownAllCores()
* TerminateApplication()

对于 ShutdownOs() 和 ShutdownAllCores() API，有应用程序配置参数（/Os/OsApplication/OsAppMkPermitShutdownOS 和 /Os/OsApplication/OsAppMkPermitShutdownAllCores）
它只允许属于该应用程序的所有**Task**任务和 **ISR** 的访问相应 **API** 函数。

对 **TerminateApplication()** 的访问处理方式不同：对于每个应用程序，允许访问它的应用程序在列表 **/Os/OsApplication/OsAppAccessingApplication** 中配置。
如果应用程序 **app1** 被配置为可以访问应用程序 **app2**，则允许应用程序 **app1** 的任务和 ISR 调用 TerminateApplication() 来控制应用程序 app2 。

在这两种情况下，如果 **API** 的访问被限制，**API** 将中止并报告错误 **MK_eid_WithoutPermission**。 否则，**API** 将继续并执行预期的功能。

## 1.11. 简单的调度表

可以使用简单调度表 (SST) 服务来执行 AUTOSAR 调度表的基本操作。它基于计数器的概念，您可以通过任务（**Task**）或 ISR 递增，或自动响应常规定时器中断。

每个计数器只有一个调度表，通过配置固定。每个调度表都有一组会时间截止点。

在计划表上的每个时间截止点，您都可以激活一个或多个任务（**Task**）或为先前激活的任务（**Task**）设置事件。

可以通过此处描述的 API 从任务（**Task**）和其他线程启动、停止和推进计数器以及它们相关的调度表。

可以根据需要配置任意数量的计数器，但可以自动递增的计数器数量受到可用硬件计时器数量的限制。

**SST** 服务实现了 **AUTOSAR** 指定的功能子集。**SST** 和标准 **AUTOSAR** 调度表之间的区别是：

* 每个 **SST** 计数器只支持一个调度表。
* 无法与外部时间源同步。
* 不执行单次操作。
* **SST** 没有等效于 **AUTOSAR** 中的 **NextScheduleTable()** API。
* 没有自动启动设施。计数器必须使用 **API** 启动。

### 1.11.1. 在EB tresos Studio中配置SST

**SST** 最好在 **EB tresos Studio** 中配置。为此请将 **OsCounter** 对象添加到您的配置中并设置其参数，如下所示：

* 将 **OsCounterType** 设置为 **SOFTWARE**。
* 将 **OsMaxAllowedValue** 设置为比计划表的所需持续时间少一。
* 将 **OsCounterMinCycle** 设置为 1。

如果您希望您的计数器定期自动递增：

* 从 **OsHwModule** 下的列表中选择一个硬件定时器。
* 输入所需的中断级别。
* 将 **OsSecondsPerTick** 设置为您需要的刻度间隔。

配置计数器后，您需要将时间表附加到它：

* 创建一个调度表，就像您为标准OS调度表所做的那样。
* 将到期点添加到调度表中。
* 将时间表附在您的计数器。
* 将 **OsScheduleTableDuration** 设置为比计数器的 **OsMaxAllowedValue** 大一。
* 将 **OsScheduleTableRepeating** 设置为 **true**。
* 将 **OsScheduleTableIsSimple** 设置为 **true**。

时间截止点的偏移量必须在 0 到持续时间的范围之间。如果有一个时间截止点的偏移量等于持续时间，它将在下一轮中以与0相同的时间点到期。但是，偏移量等于持续时间的到期点在逻辑上发生在到期点0之前，并且在启动SST后的第一轮不发生在0时刻。

SST 配置在启动期间由微内核检查。如果检测到 SST 配置中的错误，则会使用启动恐慌（**a startup panic**）来报告此情况。有关恐慌的更多信息，请参阅第 7.3.4 节 恐慌。 这意味着计数器配置的一个或多个参数超出范围。

### 1.11.2. 调用 SST 模块

要调用 **SST** 模块，请在源文件顶部包含头文件 **public/Mk_sst_api.h**。此头文件中声明的 API 可用于任何线程，例如任务（**Task**）或 ISR，但也可用于主函数。

要启动计数器及其关联的调度表，请调用 **MK_SstStartCounter(counterId,delay)**。第一个参数 **counterId** 标识您要为其启动计数器的 **SST**。您可以使用您在此处为 **SST** 指定的名称，因为 **EB tresos Studio** 会生成适当定义的宏。第二个参数 **delay** 是在第一轮调度表开始之前经过的计数器滴答数。延迟必须在 0 到 SST 持续时间的范围内，这对应于计数器的模数。

要停止计数器及其关联的简单调度表，请调用 **MK_SstStopCounter(counterId)**。该参数是针对 **MK_SstStartCounter** 描述的计数器 ID。

要推进计数器并导致处理相关的简单调度表上的到期点，请调用 **MK_SstAdvanceCounter(counterId,nTicks)**。第一个参数是针对 **MK_SstStartCounter** 描述的计数器 **ID**。第二个参数 **nTicks** 是计数器前进的刻度数，必须在 1 到 (duration-1) 的范围内。此外计数器不能有依赖于硬件的计数器，即相应的 **MK_SSTCOUNTERCONFIG()** 调用的 **tkr** 必须为 **-1**。

**第8章微内核参考手册** 给出了 **API** 函数的全面描述，包括它们可能返回的所有可能的错误代码。

### 1.11.3. 错误处理

**SST API** 函数通过返回 **StatusType** 结果代码来报告错误。对于 **MK_SstAdvanceCounter()**，结果代码还可能包括在第一个失败的激活任务（**Task**）或一组到期点操作的设置事件操作中遇到的错误，这些错误在 **SST** 计数器提前时到期。 是否调用 **EB tresos Safety OS** 的 **ErrorHook** 功能取决于任务（**Task**）的内核分配，即：已被激活或设置了哪些事件。

当 **SST** 与任务（**Task**）在同一内核心运行时，**ErrorHook**不会被调用。这意味着在处理代码中断时检测到的动态错误（例如：尝试激活已经处于活动状态的任务）将被静默忽略。

另一方面，当激活的任务或为其设置事件的任务Task位于与 **SST** 不同的内核时，则会在该内核心调用 **ErrorHook**。传递给 **ErrorHook** 的错误代码报告有关任务（**Task**）激活或事件设置的任何错误。**SST API**函数返回的结果代码与内核之间的消息传递有关。

如果作为其正常操作的一部分，**ticker** 中断函数检测到下一个中​​断的预定时间已经过去，它会调用 **ProtectionHook()** 并带有保护错误 **MK_E_INTHEPAST**。这是否被检测到取决于硬件的特性。

如果代码硬件具有自动重新加载功能，则 **SST** 不太可能检测到错误。在这种情况下，如果中断延迟超过一个时间间隔，则计数器滴答会丢失，并且到期操作的处理时间会比预期的晚。

**SST** 不会主动测量连续中断之间的时间以检测是否违反最后期限。因此，使用时序保护机制来检测违反期限和导致系统无法正常运行的其他时序错误非常重要。

# 2. 使用微内核

## 2.1. 准备你的应用程序

按照 **EB tresos AutoCore OS** 文档 [ASCOS_USERGUIDE] 中的指南开发您的应用程序。 配置 **OS** 模块以提供您需要的一组任务（**Task**）、ISR 和其他 OS 对象。

基于微内核的系统在 **EB tresos Studio** 中的配置与 **EB tresos AutoCore OS** 的配置没有区别。微内核简单地忽略了它未实现的功能配置，例如：任务特定（task-specific）或应用程序特定（**application-specific**）的hook。不过 **EB** 建议您不要在启用此类功能的情况下配置您的系统。

如果您想使用微内核提供的保护功能，您应该将您的应用程序开发为具有内存保护的可伸缩性3或4的等级。为了最大限度地免受干扰（**freedom from interference**），您不应配置任何受信任的OS应用程序（**trusted OS-Applications**）。如果有一个功能需要高权限级别才能访问硬件，您应该将该功能配置为受信任函数（**trusted function**）。

**第8.2节微内核API参考**中给出了所有已实现服务的列表。确保您的应用程序仅使用在 **EB tresos Safety OS** 中实施的 **AUTOSAR** 服务。

**验证 **EB tresos Studio** 生成的 **EB tresos Safety OS** 配置 **

如果您使用 **EB tresos Studio** 配置 **EB tresos Safety OS**，请根据 **CORTEXM** 系列 [SAFETYMANCORTEXM] 的 **EB tresos Safety OS** 安全手册中给出的标准验证生成的配置。

## 2.2. 使用微内核 API

微内核支持 **AUTOSAR-OS** 标准的一个子集。微内核还在您的任务（**Task**）和 **ISR** 以及 QM-OS 的服务（**Service**）之间提供了一个隔离层。**第8.2节微内核API参考**中描述了微内核支持的 **AUTOSAR-OS** 服务子集。

微内核将所有可执行对象，即：任务（**Task**）、ISR 和hook函数作为称为线程的对象实例来管理。这种统一性意味着您可以从任何线程调用这些服务中的大多数，包括您的挂钩函数，并期望它们能够正常工作。例如：**TerminateTask()**总是终止调用者，无论它是任务、ISR 还是hook函数。

微内核施加的唯一限制是：

* WaitEvent()、MK_WaitGetClearEvent() 和 ClearEvent() 只能从 EXTENDED 任务（**Task**）线程调用，因为只有 **EXTENDED** 任务具有这些服务所需的事件状态变量。
* 通过微内核线程接口调用的对 QM-OS 服务的调用不能从**hook函数**或**类别1的ISR**中调用，因为不允许 QM-OS 线程获得比这些线程更高的优先级。

缺乏限制意味着微内核不完全符合 **AUTOSAR** 标准。但是如果未调用未实现的服务，则为了符合 AUTOSAR 开发的系统下运行的系统在微内核下运行不会出现问题。

**在预期用途之外使用 API 函数**

请记住，能够做某事并不意味着这样做是有意义的。例如：如果您在 **ProtectionHook()** 中调用 **TerminateTask**，**ProtectionHook()** 线程将被终止。但是，在这种情况下**，ProtectionHook()** 的返回值未定义，系统基于此返回值的进一步执行也是未定义的。

如果您在预期用例之外使用 API 函数，请确保您了解后果。

## 2.3. 错误处理

**EB tresos Safety OS **中的错误处理分为三类：
* 错误（Errors），在[第2.3.1节错误](#231-错误)中描述。
* 保护故障（**Protection faults**），在[第2.3.2节保护故障](#232-保护故障)中描述。
* 恐慌（**Panics**），在[第2.3.4 节恐慌](#234-恐慌)中描述。

微内核支持标准 AUTOSAR Callout 函数 ErrorHook()、ProtectionHook() 和 ShutdownHook()。不支持特定于应用程序的 ErrorHook() 和 ShutdownHook() 函数。您必须提供hook函数。 **第8.3节微内核标注参考**中描述了它们的使用。

与标准 AUTOSAR 系统不同，微内核不直接调用 ErrorHook()、ProtectionHook() 和 ShutdownHook() 函数。 相反，它们在高优先级线程中启动。这意味着这些函数使用为它们配置的处理器模式和内存保护边界运行。 

多核环境中，Hook函数运行在检测到错误的核上，在此情况下，错误Hook可能与API的调用者不同。

### 2.3.1. 错误

当线程以错误的参数调用 **EB tresos Safety OS** 的 API 函数时，或者当系统的当前状态意味着 **EB tresos Safety OS** 无法执行请求时，会检测到错误。 

此类错误的示例如下：

* 线程传递超出范围的 ID 参数给服务。
* 线程尝试激活已达到配置的最大同时激活数的任务。
* 线程尝试获取已被占用的资源。对于 AUTOSAR来说，嵌套限制为 1。

当 **EB tresos Safety OS** 检测到错误时，微内核会使用有关错误的信息填充错误信息结构。如果在配置中启用，然后 **EB tresos Safety OS** 调用 **ErrorHook()**，并将 **AUTOSAR** 样式的错误代码作为参数传递。当**ErrorHook()**完成时，控制返回到导致错误的线程，并且在大多数情况下，**API** 函数返回 **AUTOSAR** 样式的错误代码。**API** 函数的错误代码和返回值在**第8.2节微内核API参考**的参考页面中进行了描述。

**图7.1 ErrorHook() 的调用**中描述了 **ErrorHook()** 的典型调用。

![Figure7_1](Figure7_1.png)



### 2.3.2. 保护故障

### 2.3.3. 保护hook的返回值

### 2.3.4. 恐慌